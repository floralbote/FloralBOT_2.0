# -*- coding: utf-8 -*-
"""
C√≥digo Backend para FloralBot AI - Para ser executado no Google Colab.

Instru√ß√µes:
1. Crie um novo notebook no Google Colab.
2. Copie e cole TODO este c√≥digo em uma √∫nica c√©lula do notebook.
3. No painel esquerdo, clique no √≠cone de chave (üîë) e adicione os seguintes "Secrets":
   - DATABASE_URL: Sua string de conex√£o do PostgreSQL.
   - JWT_SECRET: Uma chave secreta longa e aleat√≥ria.
   - NGROK_AUTHTOKEN: Seu token de autentica√ß√£o do ngrok.
   - **IMPORTANTE**: Ative a op√ß√£o "Notebook access" para todos os secrets.
4. Execute a c√©lula. Ela instalar√° as depend√™ncias e iniciar√° o servidor.
5. A URL p√∫blica do ngrok ser√° impressa no final da sa√≠da. Use-a no seu frontend.
"""

# @title C√ìDIGO DO SERVIDOR - COLE TUDO ISTO EM UMA C√âLULA
# Instala as depend√™ncias necess√°rias
!pip install Flask==2.2.2 psycopg2-binary==2.9.5 bcrypt==4.0.1 PyJWT==2.6.0 python-dotenv==0.21.0 Flask-Cors==3.0.10 flask-ngrok==0.0.25

# Importa√ß√µes de bibliotecas
import os
import bcrypt
import jwt
import psycopg2
from psycopg2 import pool
from datetime import datetime, timedelta
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from flask_ngrok import run_with_ngrok
from google.colab import userdata

# --- Configura√ß√£o Inicial ---
print("Inicializando a aplica√ß√£o Flask...")
app = Flask(__name__, static_folder='.', static_url_path='')
CORS(app)
run_with_ngrok(app) # Inicia o ngrok quando o app rodar

# --- Configura√ß√£o das Vari√°veis de Ambiente (Secrets) ---
try:
    print("Carregando secrets do Google Colab...")
    DATABASE_URL = userdata.get('DATABASE_URL')
    JWT_SECRET = userdata.get('JWT_SECRET')
    NGROK_AUTHTOKEN = userdata.get('NGROK_AUTHTOKEN')

    if not all([DATABASE_URL, JWT_SECRET, NGROK_AUTHTOKEN]):
        raise ValueError("Uma ou mais secrets n√£o foram encontradas. Verifique a configura√ß√£o.")

    # Configura o token de autentica√ß√£o do ngrok
    os.environ['NGROK_AUTHTOKEN'] = NGROK_AUTHTOKEN
    print("Secrets carregadas com sucesso.")

except Exception as e:
    print(f"\n!!! ERRO CR√çTICO AO CARREGAR SECRETS !!!")
    print(f"Detalhe do erro: {e}")
    print("Por favor, verifique se voc√™ configurou 'DATABASE_URL', 'JWT_SECRET', e 'NGROK_AUTHTOKEN' na aba 'Secrets' (üîë) do Colab.")
    print("Certifique-se tamb√©m de que a op√ß√£o 'Notebook access' est√° ativada para cada uma delas.")
    # Interrompe a execu√ß√£o se as secrets n√£o estiverem configuradas
    raise SystemExit("Execu√ß√£o interrompida devido √† falta de secrets.")


# --- M√≥dulo de Banco de Dados ---
db_pool = None
try:
    print("Configurando o pool de conex√µes com o PostgreSQL...")
    db_pool = psycopg2.pool.SimpleConnectionPool(1, 10, dsn=DATABASE_URL)
    # Testa a conex√£o pegando e devolvendo um cliente
    conn_test = db_pool.getconn()
    print("Conex√£o com o banco de dados PostgreSQL estabelecida com sucesso!")
    db_pool.putconn(conn_test)
except Exception as e:
    print(f"\n!!! ERRO CR√çTICO AO CONECTAR AO BANCO DE DADOS !!!")
    print(f"Detalhe do erro: {e}")
    raise SystemExit("Execu√ß√£o interrompida. N√£o foi poss√≠vel conectar ao banco de dados.")

def execute_query(query, params=None, fetch=None):
    """
    Fun√ß√£o auxiliar para executar queries no banco de dados usando o pool de conex√µes.
    """
    conn = None
    try:
        conn = db_pool.getconn()
        with conn.cursor() as cur:
            cur.execute(query, params)
            if fetch == 'one':
                return cur.fetchone()
            if fetch == 'all':
                return cur.fetchall()
            conn.commit()
    except Exception as e:
        print(f"Erro ao executar a query: {e}")
        # Se houver um erro, desfa√ßa a transa√ß√£o
        if conn:
            conn.rollback()
        raise e
    finally:
        if conn:
            db_pool.putconn(conn)

# --- Rotas da API de Autentica√ß√£o ---

@app.route('/auth/register', methods=['POST'])
def register_user():
    """Endpoint para registrar um novo usu√°rio."""
    data = request.get_json()
    name = data.get('name')
    email = data.get('email')
    password = data.get('password')

    if not all([name, email, password]):
        return jsonify({"message": "Por favor, forne√ßa todos os campos necess√°rios."}), 400

    try:
        # Verifica se o email j√° existe
        user_exists_query = "SELECT * FROM users WHERE email = %s"
        existing_user = execute_query(user_exists_query, (email,), fetch='one')

        if existing_user:
            return jsonify({"message": "O e-mail fornecido j√° est√° em uso."}), 409

        # Criptografa a senha
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

        # Insere o novo usu√°rio
        insert_query = "INSERT INTO users (name, email, password) VALUES (%s, %s, %s) RETURNING id"
        new_user = execute_query(insert_query, (name, email, hashed_password.decode('utf-8')), fetch='one')

        return jsonify({"message": "Usu√°rio criado com sucesso", "userId": new_user[0]}), 201

    except Exception as e:
        return jsonify({"message": f"Erro no servidor durante o registro: {e}"}), 500


@app.route('/auth/login', methods=['POST'])
def login_user():
    """Endpoint para autenticar um usu√°rio e retornar um token JWT."""
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not all([email, password]):
        return jsonify({"message": "Por favor, forne√ßa e-mail e senha."}), 400

    try:
        # Busca o usu√°rio pelo e-mail
        select_query = "SELECT * FROM users WHERE email = %s"
        user_row = execute_query(select_query, (email,), fetch='one')

        if not user_row:
            return jsonify({"message": "Credenciais inv√°lidas."}), 401

        # Mapeia a tupla para um dicion√°rio para facilitar o acesso
        user = {
            "id": user_row[0],
            "name": user_row[1],
            "email": user_row[2],
            "password": user_row[3]
        }

        # Verifica a senha
        if not bcrypt.checkpw(password.encode('utf-8'), user['password'].encode('utf-8')):
            return jsonify({"message": "Credenciais inv√°lidas."}), 401

        # Gera o token JWT
        payload = {
            'userId': user['id'],
            'name': user['name'],
            'exp': datetime.utcnow() + timedelta(hours=1)
        }
        token = jwt.encode(payload, JWT_SECRET, algorithm='HS256')

        return jsonify({
            "token": token,
            "userName": user['name'],
            "userEmail": user['email']
        }), 200

    except Exception as e:
        return jsonify({"message": f"Erro no servidor durante o login: {e}"}), 500

# Rota de teste para verificar se o servidor est√° no ar
@app.route("/")
def home():
    return "<h1>Servidor Flask para FloralBot AI est√° rodando!</h1><p>Use os endpoints /auth/register e /auth/login.</p>"


# --- Inicia o Servidor ---
if __name__ == '__main__':
    print("\n--- INSTRU√á√ïES FINAIS ---")
    print("O servidor Flask est√° sendo iniciado...")
    print("Aguarde a URL p√∫blica do ngrok ser exibida abaixo.")
    print("Copie a URL (algo como https://xxxxxxxx.ngrok-free.app) e cole na constante 'API_BASE_URL' nos arquivos 'LoginPage.tsx' e 'SignupPage.tsx' do seu frontend.")
    print("--------------------------\n")
    app.run()
